# mysql的架构与历史

## MySQL的逻辑架构

![image-20210208144329481](../../java/base/image-20210208144329481.png)

### 连接管理与安全性

​		每个客户端连接都具在服务器拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会缓存线程，因此不需要为每个新建的连接创建或者销毁线程。

### 优化与执行

​		优化器对查询进行优化， 但是不关心表使用的是什么存储引擎，但存储引擎对优化查询时有影响的。

## 并发控制

​		服务器层与存储引擎层的并发控制。

### 读写锁

​		共享锁和排它锁，也叫做读锁和写锁。读锁是共享的，或者说是相互不阻塞的。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度

- 表锁（table lock）：开销最小的策略，会锁整个表。
- 行级锁（row lock）：可以最大成都地支持并发处理（同时也带来最大地锁开销）。

## 事务

- 原子性
- 一致性
- 隔离性：一个事务所做地修改在最终提交以前，对其他事务是不可见的。
- 持久性：一旦事务提交，则其所作的修改就会永久保存到数据库中。

### 隔离级别

- READ UNCOMMITTED（未提交读）：事务的修改，即使没提交，对其他事务也都是可见的。事务可以读取未提交的数据，这被叫做脏读，实际中很少使用。
- READ COMMITTED(提交读)：也叫不可重复读，两次执行同样的查询，可能得到不同的结果，会出现幻读的情况。幻读就是当某个事务在读取某个范围内的记录时，另外一个是事务又在该范围内插入了新的记录，之前的事务再次读取该范围的记录时，会产生幻行。
- REPEATABLE READ（可重复读）：是mysql的默认隔离级别，解决了幻行的情况。
- SERIALIZABLE(可串行化)：是最高的隔离级别，通过强制事务串行执行，避免了幻读问题，但可能会造成大量的超时和锁争用的问题。

### 死锁

​		两个或者多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环的现象。InnoDB存储引擎，会检查到死锁的循环依赖，并立即返回一个错误。

### 事务日志

​		事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久再硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

### MySQL中的事务

- 自动提交：如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。可通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式
- 在事务中混合使用存储引擎：事务是由下层的存储引擎实现的，所以在同一事务中，使用多种存储引擎是不可靠的。
- 隐式和显式锁定：mysql默认为隐式锁定。

## 多版本并发控制

MYSQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了多版本并发控制（MVCC)。它是行级锁的一个变种，但是它在很多情况下避免了枷锁操作，因此开销更低。

## MySQL的存储引擎

### InnoDB存储引擎

​		InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期事务。

- InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。
- InnoDB采用MVCC来支持高并发，并实现了四个标注你的隔离级别。
- InnoDB表是基于聚簇索引建立的。